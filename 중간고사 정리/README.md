# 앱프로그래밍 중간고사 대비 요약

## 파트 1: 이론 요약 (Lecture PDF 기반)

### 1. 기초사항 – 스마트폰과 안드로이드 기본 개념
- **스마트폰의 개념:** 스마트폰은 **컴퓨터 + MP3 플레이어 + 휴대용 게임기**의 기능을 합친 기기이다. 다양한 **애플리케이션 설치**가 가능하여, 기존 피처폰보다 훨씬 확장된 기능을 제공한다. 예를 들어 *“MP3 플레이어, 휴대용 게임기, 스마트폰과 같이 앱 설치가 가능한 기기”*를 묻는다면 정답은 **스마트폰**이다.
- **모바일 운영체제(Mobile OS):** 스마트폰이나 태블릿 등 모바일 기기를 위한 운영체제이다. 대표적으로 **구글 안드로이드(Android)**와 **애플 iOS**가 있다. (안드로이드는 개방형 플랫폼이고, iOS는 폐쇄형 플랫폼으로 자사 기기에서만 동작 등 차이가 있지만, 시험에서는 세부 비교보다는 안드로이드 자체에 집중.)
- **안드로이드 소개:** 안드로이드는 구글에서 인수하여 개발한 **모바일 운영체제**로, 리눅스 커널을 기반으로 한다. 2008년 최초 상용 버전이 등장했고 현재 세계에서 가장 널리 쓰이는 스마트폰 OS이다. (역사적 세부사항 출제하지 않음 – **연도나 개발자 이름 등은 시험 범위 아님**.)
- **안드로이드의 주요 특징:** 안드로이드가 가진 핵심 특징들은 다음과 같다 (객관식 지문으로 출제될 수 있음):
  - **리눅스 커널 기반:** 보안, 프로세스 관리 등 핵심을 리눅스 커널로 구현함.
  - **애플리케이션 프레임워크 제공:** 앱 개발을 위한 표준화된 프레임워크(API)를 제공하여, 개발자가 쉽고 일관되게 앱을 만들 수 있음.
  - **자바/Kotlin 언어 사용:** 안드로이드 앱은 주로 **Java 또는 Kotlin** 언어로 작성된다. (과거에는 Java 중심, 현재 Kotlin도 공식 지원)
  - **최적화된 그래픽:** OpenGL ES 2.0 기반의 3D 그래픽 지원 등 **고성능 그래픽 처리** 가능.
  - **SQLite DB 내장:** 경량화된 **SQLite 데이터베이스**를 내장하여 앱에서 손쉽게 데이터베이스 활용 가능.
  - **다양한 멀티미디어 지원:** MPEG4, H.264, MP3, AAC, JPG, PNG, GIF 등 **다양한 동영상/오디오/이미지 포맷**을 지원.
  - **풍부한 하드웨어 지원:** 블루투스, 3G/4G/5G, Wi-Fi 등의 **네트워크**와 카메라, GPS, 나침반, 가속도 센서 등 **스마트폰 하드웨어** 기능을 폭넓게 지원.
  - **개발 및 디버깅 환경 제공:** **에뮬레이터(가상 디바이스)** 제공으로 실제 기기 없이 테스트 가능하고, 메모리/성능 프로파일러 등 개발자 도구를 갖춘 **풍부한 개발환경**을 지원.
- **안드로이드 앱 개발환경:** **Android Studio**를 사용. Android Studio는 구글이 제공하는 공식 **통합 개발도구(IDE)**로, 코딩(edit), 빌드 및 에뮬레이터 실행, 디버깅을 한 곳에서 수행한다. 초기 환경 구축 시 **JDK 설치, Android SDK 설치, 환경변수 설정** 등을 거치지만, 세부 절차는 시험에 출제되지 않는다. 대신 **Android Studio가 무엇인지, 왜 사용하는지**를 이해해야 한다. (예: *“안드로이드 스튜디오란 무엇인가?”* 또는 *“다음 중 안드로이드 스튜디오에 대한 설명으로 옳지 않은 것은?”* 형태의 문제 대비)

### 2. 애플리케이션 기본 구조 – 안드로이드 앱 구성요소
- **안드로이드 앱의 4대 구성요소:** 안드로이드 애플리케이션은 **컴포넌트(component)**라는 단위 요소들로 구성된다. **액티비티(Activity)**, **서비스(Service)**, **방송 수신자(Broadcast Receiver)**, **컨텐트 제공자(Content Provider)** 이 네 가지가 대표적이다. *(시험 TIP: 4대 컴포넌트 이름을 모두 기억하고, 역할을 이해할 것. 방송 수신자와 콘텐츠 제공자는 수업 시간에 깊이 다루지 않았지만, **이름과 개념** 정도는 알아두기)*
  - **액티비티(Activity):** **화면을 구성**하는 컴포넌트로, 사용자 인터페이스(UI)를 담당한다. 사용자가 보는 한 화면(예: 로그인 화면, 설정 화면 등)이 하나의 액티비티이다. 액티비티는 **사용자와의 상호작용**을 관리하며, 액티비티 간 전환은 **인텐트(Intent)**를 통해 이루어진다. (예: 버튼 클릭으로 새 액티비티 실행 등)
  - **서비스(Service):** **백그라운드 처리**를 담당하는 컴포넌트로, 화면 UI 없이 동작한다. 예를 들어 음악 재생 앱의 백그라운드 음악 재생, 알람 처리 등 사용자 눈에 보이지 않고 **장기간 작업**을 수행하는 부분은 서비스로 구현한다.
  - **방송 수신자(Broadcast Receiver):** **시스템이나 다른 앱에서 발생하는 브로드캐스트 이벤트를 수신**하는 컴포넌트이다. 예를 들어, 배터리 부족 경고나 화면 껌/켜짐 이벤트 등을 Broadcast로 보내면, 해당 이벤트를 듣도록 등록된 컴포넌트가 Broadcast Receiver이다. (※ 본 수업에서는 상세 구현은 다루지 않음)
  - **컨텐트 제공자(Content Provider):** **앱 간 데이터 공유를 담당**하는 컴포넌트이다. SQLite DB나 파일 등을 통해 저장된 데이터를 다른 애플리케이션이 질의(Query)하여 가져갈 수 있도록 인터페이스를 제공한다. 예를 들어 주소록 앱의 연락처 데이터를 다른 앱이 읽어오도록 할 때 Content Provider를 사용. (※ 수업에 상세히 다루지 않음)
- **안드로이드 vs PC 애플리케이션 차이:** **안드로이드 앱은 다른 애플리케이션의 컴포넌트를 활용**할 수 있지만, **전통적인 PC 애플리케이션은 다른 프로그램의 코드를 직접 사용할 수 없다**. 즉, 안드로이드에서는 인텐트 등을 통해 **앱 간 연동**이 가능하다 (예: 내 앱에서 **카메라 앱**의 액티비티를 호출하여 사진 찍기, **공유하기** 기능으로 다른 앱을 띄우기 등). 반면 PC 프로그램은 보통 자기 프로그램 내부 코드만 실행하고, 다른 프로그램의 기능을 바로 호출하는 통합 환경이 없다. 이 밖에도 안드로이드 앱은 **여러 Entry Point**를 가지는 등 구조가 다르고 (액티비티마다 별도 진입점), **수명주기(Lifecycle)** 관리가 시스템에 의해 이루어진다는 점도 특징이다. (Lifecycle에 대해서는 추후 학습, **이번 시험엔 상세 생명주기 다루지 않음**)
- **인텐트(Intent)의 개념:** 인텐트는 **컴포넌트 간 통신을 위한 메시지 객체**이다. 쉽게 말해 “~~한 일을 해줘”라는 **의도(Intent)**를 안드로이드 시스템에 전달하면, 해당 의도를 처리할 수 있는 적절한 컴포넌트를 찾아 실행해준다. 인텐트는 액티비티를 시작하거나(예: 화면 전환), 서비스 시작, Broadcast 전달 등에 사용된다. 예를 들어 **명시적 인텐트**(explicit intent)는 특정 컴포넌트를 콕 집어 실행하고, **암시적 인텐트**(implicit intent)는 “이런 기능을 할 수 있는 컴포넌트 알아서 찾아줘” 하고 시스템이 적절한 앱/컴포넌트를 찾아 실행한다. *(시험 대비: 인텐트 정의 및 역할을 묻는 서술형 가능)*
- **매니페스트(Manifest)와 앱 구성:** 안드로이드 앱에는 `AndroidManifest.xml` 파일이 포함되어, 앱의 **구성요소 선언(액티비티, 서비스 등 등록)**, **권한(Permissions)**, 앱 **버전 정보** 등을 명시한다. 앱을 만들 때 **일반적인 절차**는 프로젝트 생성 → 화면 구성(XML 레이아웃 작성) → 컴포넌트 Java/Kotlin 코드 작성 → 매니페스트 등록 → 빌드 & 실행 순으로 이루어진다. (단, 이러한 절차를 장황히 서술하는 문제는 출제되지 않을 예정이므로 흐름만 이해하고 상세 암기는 불필요)

### 3. 기본 위젯(1) – 사용자 인터페이스 개요와 텍스트/버튼 위젯 
- **뷰(View)와 뷰그룹(ViewGroup):** 안드로이드의 UI 요소는 **View**와 **ViewGroup**으로 나뉜다. **View**는 화면에 그려지는 기본 개체(예: 버튼, 텍스트 등 **눈에 보이는 UI 요소**), **ViewGroup**은 여러 View를 담는 컨테이너로 **레이아웃(Layout)** 역할을 한다. 모든 UI는 뷰와 뷰그룹 계층 구조로 구성된다 (뷰그룹이 자식으로 뷰를 품는 형태).
- **UI 작성 방법:** UI를 만드는 방법은 **두 가지**가 있다. 하나는 **XML 레이아웃 파일**을 작성하는 방법이고, 다른 하나는 **자바/Kotlin 코드**로 View 객체들을 생성하여 배치하는 방법이다. 일반적으로 **XML로 디자인**하고 필요하면 코드에서 동적으로 View를 추가/변경하는 혼합 방법을 쓴다. (XML로 UI를 정의하면 직관적이고 분리가 용이하여 주로 사용함)
- **기본 위젯 소개:** 안드로이드에서 자주 쓰이는 **기본 위젯(controls)**들이 있다. 시험에서는 각 위젯의 **용도와 특징**을 이해하고 있어야 한다 (구현 함수 암기보다는 *“무엇을 하는 UI인지”* 아는 것이 중요).
  - **텍스트뷰(TextView):** 화면에 **텍스트를 표시**하는 위젯. Label과 같이 출력 전용으로 사용된다. 사용자 입력은 받을 수 **없다** (읽기 전용).
  - **에디트텍스트(EditText):** **사용자에게 입력을 받을 수 있는** 한 줄 텍스트 입력 필드. 다른 말로 **텍스트 박스**라고도 한다. 키보드 입력을 통해 사용자로부터 문자열 등을 입력받는다. (TextView와 EditText의 **차이**는 출제 빈도가 높음: EditText는 **편집 가능**한 입력 필드라는 것 강조)
  - **버튼(Button):** 가장 기본적인 **클릭 가능한 버튼** 위젯. 사용자가 누르면(onClick) 어떤 동작을 수행한다. 버튼을 누르는 동작에 반응하여 **이벤트 처리** 코드를 실행할 수 있다. 예를 들어 “확인” 버튼, “취소” 버튼 등을 만들 수 있으며, **setOnClickListener** 등을 통해 클릭 시 동작을 코딩한다.
  - *(기본 위젯(1) 수업에서는 주로 위 세 가지—텍스트 출력, 입력, 버튼—을 다루고, 이후 예제를 통해 EditText에서 입력받아 처리하는 것을 연습함. 과제1도 이와 관련.)*
- **간단한 UI 실습 예제:** XML 레이아웃으로 두 개의 버튼을 배치하는 예제 등을 통해 UI 작성법을 연습했다. 예를 들어, LinearLayout 뷰그룹 내에 `<Button>` 두 개를 정의하고 `layout_width`, `layout_height` 등을 설정하는 연습. 이 과정에서 **레이아웃 속성**인 `wrap_content`와 `match_parent`의 사용법을 익혔다:
  - `wrap_content`: **컨텐츠 내용에 맞게** 뷰 크기를 조절하는 설정. (예: 버튼의 text 길이에 딱 맞는 크기로 버튼 너비를 설정)
  - `match_parent` (과거 `fill_parent`): 부모 뷰그룹의 크기에 **맞춰서 뷰를 확장**하는 설정. (예: 화면 전체 너비를 채우도록 설정)
  - *(시험 TIP: wrap_content vs match_parent 개념을 이해하고 있을 것. 간단한 객관식이나 빈칸 문제로 나올 수 있음)*
- **이벤트 처리 개요:** 버튼을 클릭하면 어떻게 동작을 정의할까? XML에서 `<Button>` 태그에 `android:onClick="함수명"`을 지정하고 액티비티에서 해당 함수를 구현하거나, 코드에서 `button.setOnClickListener`를 사용하여 **리스너를 연결**할 수 있다. 초반 실습에서는 주로 **onClickListener를 구현**하여 버튼 클릭 -> 코드 실행 흐름을 다뤘다. 예를 들어 버튼 클릭 시 EditText에서 텍스트를 가져와서(TextView에 표시하거나 Toast 메시지 출력). 이때 EditText의 내용은 `editText.getText().toString()`으로 가져온다. (`getText()`만 하면 **Editable** 객체이므로 사람이 읽을 문자열로 변환 위해 `toString()` 필요.)

### 4. 기본 위젯(2) – 이미지 및 추가 위젯, 응용 예제
- **이미지뷰(ImageView)와 이미지버튼(ImageButton):** 이미지를 화면에 표시하는 UI 요소. **ImageView**는 단순히 이미지를 보여주기만 하고, **ImageButton**은 이미지를 배경으로 갖는 **클릭 가능한 버튼**이다. 예를 들어 아이콘을 누르는 버튼을 만들 때 ImageButton을 사용한다. 안드로이드에서 지원하는 이미지 형식은 JPEG, PNG, GIF 등이 있으며, XML에서 `src`나 `background` 속성으로 이미지를 설정한다.
- **토글 버튼(ToggleButton) 및 스위치(Switch):** (언급은 없었지만 기본 위젯 범주) 두 상태를 가지는 온오프 스위치 형태의 위젯. ToggleButton은 “눌림/안눌림” 상태를 가지는 버튼, Switch는 현대 안드로이드에서 토글 대신 자주 쓰이는 스위치 UI이다. **체크박스(CheckBox)**와 유사하지만, 보통 설정 화면 등에 쓰이며 하나만 독립적으로 On/Off 토글할 때 사용.
- **라디오 버튼(RadioButton)과 라디오그룹(RadioGroup):** 여러 개 중 **하나만 선택**할 수 있는 옵션을 제공할 때 사용. 라디오버튼은 개별 항목, 라디오그룹은 그 항목들을 묶어주는 컨테이너이다. 동일 라디오그룹 내에서는 한 버튼만 체크되도록 자동제어된다. (예: 성별 선택 남/여처럼 둘 중 하나만 선택)
- **체크박스(CheckBox):** **다중 선택이 가능한** 체크 항목. 여러 개를 **동시에 선택**할 수 있다. 각 체크박스는 개별적으로 on/off 값을 가지며, 독립적으로 사용하거나 리스트 항목 선택 등에 쓰인다.
- *(위 위젯들에 대해서는 수업 시간에 간단히 소개되었으며, 시험에서는 **“어떤 상황에 어떤 위젯을 쓰는지”** 또는 **위젯의 특징(예: EditText vs TextView 차이)** 정도를 물을 수 있다. 교수님 언급: “RadioButton, CheckBox 등의 디테일까지 외우는 시험은 아니고, **각 위젯의 역할**만 이해하면 된다” )*
- **예제 – 이미지 뷰 조작 앱:** 수업 중 이미지뷰와 버튼을 활용한 간단한 응용 예제를 실습했다. 예를 들어 **이미지 뷰어 앱**처럼 하나의 ImageView와 두 개의 Button을 만들어, 하나는 이미지를 **투명하게(Alpha 변화)**, 하나는 이미지를 **회전(Rotate)**하는 동작을 구현했다. 버튼을 누를 때 실행되는 코드에서 `imageView.setAlpha()` 메소드로 **투명도 값을 조절**하거나, `imageView.setRotation()` 또는 애니메이션 기능을 사용해 **이미지를 회전**시켰다. 이 예제를 통해 **속성 변경을 통한 뷰 조작**과 **애니메이션 기본**을 배웠다. *(시험 TIP: 이 코드 흐름 이해하기 – 예: 알파값 0이면 완전 투명(안 보임), 1이면 불투명 등의 개념. 회전은 각도를 지정하여 이미지 뷰를 회전시킴)*

### 5. 레이아웃(1) – UI 레이아웃 기본 및 주요 레이아웃 유형
- **레이아웃이란:** 레이아웃은 **뷰그룹(ViewGroup)**의 일종으로, **다른 뷰들을 배치하고 정렬하는** 컨테이너 역할을 한다. 화면 UI를 설계할 때 다양한 레이아웃 방식을 활용하여 요소들을 보기 좋게 배열한다. 안드로이드의 대표적인 레이아웃 클래스로 **LinearLayout, RelativeLayout, TableLayout, GridLayout, FrameLayout, ConstraintLayout** 등이 있다. (이 중 본 수업에서는 Linear, Table, Grid, Relative, Constraint를 다룸)
- **리니어레이아웃(LinearLayout):** **수평** 또는 **수직** **방향으로 일렬로 뷰들을 배치**하는 레이아웃. `android:orientation` 속성으로 방향을 설정 (`horizontal`이면 가로로, `vertical`이면 세로로 배치). 화면에 순서대로 쌓이는 구조라 이해하기 쉽고 자주 사용된다. 여러 요소를 균등 분배하거나 한 줄에 배치할 때 활용. 
  - 예: 회원가입 폼에서 레이블(TextView)과 입력란(EditText)을 한 줄로 놓고 싶을 때 Horizontal LinearLayout으로 묶어서 배치.
- **테이블레이아웃(TableLayout)과 그리드레이아웃(GridLayout):** **행(row)과 열(column)** 개념으로 뷰를 배치하는 레이아웃. TableLayout은 `<TableRow>` 단위를 사용하여 행별로 자식을 배치하고, GridLayout은 행×열 좌표에 뷰를 배치한다. 일정한 표 형태의 배치가 필요할 때 사용한다. 
  - 예: 계산기 앱의 버튼 배치를 4x4 표처럼 정렬하거나, 일정표를 나타낼 때 활용. (GridLayout은 TableLayout의 개선형으로 유연한 크기 조절 가능)
- *(절대좌표로 배치하는 AbsoluteLayout는 과거에 존재했으나 현재는 사용 지양.)*

### 6. 레이아웃(2) – 고급 레이아웃 및 화면 최적화
- **상대레이아웃(RelativeLayout):** **다른 뷰나 부모를 기준으로 상대적으로 위치**를 지정하는 레이아웃. 각 뷰의 `layout_alignParentTop`, `layout_centerHorizontal` 또는 다른 뷰에 대한 `layout_below`, `layout_toRightOf` 등의 속성을 통해 **상대적인 배치**를 한다. LinearLayout처럼 단순 일렬이 아니라, **겹치거나 복잡한 배치**도 가능하여 유연하다. (하지만 규칙 이해가 필요하고, 복잡할 경우 코드가 난잡해질 수 있음)
  - 예: 프로필 화면에서 아바타 이미지의 오른쪽에 이름 텍스트를 놓고, 그 아래에 상태 메시지를 배치하는 등 위치를 세밀하게 조정할 때 RelativeLayout 사용.
- **제약 레이아웃(ConstraintLayout):** 최신 안드로이드에서 권장되는 **유연하고 강력한 레이아웃**. RelativeLayout의 장점을 발전시킨 것으로, **제약 조건(Constraints)**을 이용해 뷰들 간의 상대적 위치를 자유롭게 지정한다. 각각의 뷰에 대해 *위, 아래, 왼쪽, 오른쪽* 등 **Anchor**를 다른 뷰나 부모에 연결하여 복잡한 UI도 한 레이아웃 안에서 관리 가능. 성능이 좋고 중첩 레이아웃을 줄일 수 있어 복잡한 화면 구성에 자주 쓰임. (초반 러닝커브가 있지만, GUI 툴을 통해 쉽게 제약을 줄 수도 있음)
  - 예: 로그인 화면을 ConstraintLayout으로 설계하면, “아이디 입력” EditText를 부모 위쪽에 20dp 띄우고 가운데 정렬 + “비밀번호 입력” EditText를 그 아래에 일정 간격으로 배치 + 로그인 버튼을 하단에 배치 등 세밀한 배치를 한 레이아웃 안에서 정의 가능.
- **레이아웃 최적화와 기타 속성:** 다양한 화면 크기에 대응하기 위해 레이아웃을 설계할 때 **권장 단위인 dp와 sp**를 사용하고, `wrap_content`/`match_parent`를 적절히 활용한다. 또한 **중첩된 레이아웃**을 너무 많이 사용하면 성능이 저하될 수 있으므로 ConstraintLayout 등으로 합치는 방법도 있다. XML 속성 중 `android:layout_weight` (LinearLayout에서 공간 비율 조정) 같은 것도 있지만, 본 시험 범위에서는 기본 속성 위주로 이해하면 된다. 
  - **px, dp, sp 단위:** 화면 요소 크기를 지정할 때 **픽셀(px)**은 실제 화면 해상도의 물리 픽셀 단위라서 디스플레이 밀도에 따라 크기가 달라진다. **dp**(또는 dip, Density-independent Pixel)는 **화면 밀도에 독립적인** 가상 픽셀 단위로, 어느 기기에서나 물리적 크기가 비슷하게 유지된다 (중간 밀도 기준 1dp≈1px, 고밀도 기기에서는 1dp가 여러 px로 설정되어 크기를 보정). **sp**(Scale-independent Pixel)는 **사용자 글꼴 크기 설정을 반영한** 단위로, 주로 **글꼴 크기** 지정에 사용된다. 예를 들어 글자 크기를 16sp로 지정하면 사용자가 시스템 글꼴 크기를 크게 설정했을 경우 그에 비례해 더 크게 표시된다. *(시험 단골: px/dp/sp 정의 및 차이, 적절한 사용 예시)*
  - **background vs backgroundTint:** (참고) `android:background`는 뷰의 배경을 Drawable이나 색상으로 지정하는 속성이고, `android:backgroundTint`는 배경 Drawable에 색상 필터를 입혀 **색상만 변경**하는 속성이다. 예를 들어 기본 회색 버튼에 `backgroundTint`로 빨강을 주면 버튼 모양은 유지되고 색만 빨갛게 변한다. (교수님 언급으로 간단히 짚은 내용 – 세부사항 깊이 출제되진 않음)

## 파트 2: 실습 요약 (GitHub 과제 코드 중심)

이 부분에서는 강의에서 진행된 **주요 실습 과제**들의 내용과 **코드 동작 흐름**을 요약한다. 각 과제에서 어떤 기능을 구현했고, 핵심 코드가 어떤 흐름으로 작동하는지 쉽게 풀어 정리했다.

### 과제 1: 에디트텍스트 활용 앱 (텍스트 입력/출력 실습)
- **과제 개요:** EditText로 사용자 입력을 받고, 버튼을 눌러 그 입력값을 처리한 후 화면에 결과를 보여주는 간단한 앱을 구현. (예시 시나리오: 사용자가 이름을 입력하면 화면에 “Hello, [이름]!”을 띄우는 앱)
- **주요 화면 구성:** EditText 1개 (텍스트 입력 필드), Button 1개 (“확인” 버튼 등), TextView 1개 (결과 표시용 레이블).  
- **동작 흐름:**  
  1. 사용자가 EditText에 텍스트를 입력한다 (예: `홍길동`).  
  2. 사용자가 Button을 클릭하면, 해당 버튼의 **onClick 이벤트 리스너**가 호출된다.  
  3. 코드에서는 EditText로부터 입력된 내용을 가져오기 위해 `editText.getText()`를 호출하고, 이어서 `.toString()`을 붙여 **일반 문자열(String)**으로 변환한다. (이때 `getText()`만 쓰면 **Editable 객체**가 반환되므로, 사람이 쓰는 문자열로 변환하려면 `toString()`이 필요함 – ***왜 `toString()`을 쓰는지 시험에 나올 수 있음**)  
  4. 가져온 문자열 (예: "홍길동")을 가공하거나 바로 사용한다. 이번 과제에선 간단히 "Hello, 홍길동!" 형태로 앞에 인사말을 붙이는 등의 처리를 함.  
  5. 처리된 결과 문자열을 TextView에 `textView.setText(결과문자열)`로 설정하여 화면에 보여준다. (만약 TextView 없이 토스트(Toast) 메시지로 출력했다면 `Toast.makeText(...).show()`를 사용했을 수도 있지만, 여기서는 TextView 활용)  
- **핵심 포인트:** EditText로부터 텍스트를 **가져오는 방법**과 Button 클릭 이벤트 처리. 특히 **`getText().toString()`의 필요성**을 이해하는 것이 중요하다. (사용자 입력을 다른 변수에 숫자로 변환하는 과제가 있었다면 `Integer.parseInt(editText.getText().toString())` 같이 활용했을 것임.)

### 과제 2: 회원가입 폼 화면 구성 (다중 입력 폼 실습)
- **과제 개요:** 여러 개의 입력 필드와 선택지를 가진 **회원가입 양식 UI**를 만들고, 입력된 정보를 취합/확인하는 앱을 구현. 주 목표는 **여러 종류의 위젯과 레이아웃을 활용**하여 폼을 꾸미는 것.
- **주요 화면 구성:**  
  - **텍스트 입력:** 이름, 이메일, 비밀번호 등 **EditText 여러 개**. (예: 이름, ID, PW 세 칸)  
  - **선택 입력:** 성별 선택을 위한 **RadioGroup + RadioButton(남/여)**, 취미 선택 등의 **CheckBox** 여러 개 (있다면).  
  - **액션 버튼:** “가입하기” 등 완료 동작을 위한 **Button**.  
  - **레이아웃:** 항목들을 보기 좋게 정렬하기 위해 LinearLayout의 중첩 또는 TableLayout 등을 사용. 예를 들어 각각의 `TextView(레이블): EditText(필드)` 쌍을 Horizontal LinearLayout으로 묶어 세로로 나열. 또는 TableLayout으로 2열(레이블/입력) 구조 배치. 전체 폼은 ScrollView로 감싸 화면 넘침 대비(필요 시).  
- **동작 흐름:** (UI 구성 위주 과제이므로 동작은 단순)  
  1. 사용자가 여러 입력란(EditText)에 정보를 입력하고, RadioButton/CheckBox를 필요한 대로 선택한다.  
  2. “가입하기” 버튼을 클릭하면 각 입력 필드와 선택 요소들의 현재 값을 **코드에서 읽어옴**. EditText는 앞서처럼 `getText().toString()`으로 문자열 획득, RadioGroup은 `radioGroup.getCheckedRadioButtonId()` 등을 통해 선택된 RadioButton 식별, CheckBox는 각각 `checkBox.isChecked()`로 boolean값 획득.  
  3. 수집된 정보로 **간단한 검증 or 확인 처리**. (예: 필수 항목이 비었으면 "이름을 입력하세요" 경고 Toast, 아니면 입력된 정보 묶어서 화면에 출력 혹은 Log 출력 등)  
  4. (선택적) 완료 메시지를 Toast로 띄우거나 새로운 액티비티/화면으로 넘기는 동작. 이 과제에서는 주로 **화면 설계**와 **위젯 값 읽어오기**까지 구현했다. 실제 서버 전송 등은 없음.  
- **핵심 포인트:** 여러 위젯을 폼 형태로 **배치하는 레이아웃 설계** 능력 및 각종 입력 요소의 값 **취합 방법**. LinearLayout의 Orientation, nested LinearLayout, 또는 TableLayout 사용에 익숙해져야 했다. 또한 RadioButton과 CheckBox의 차이(단일 선택 vs 다중 선택)를 이해하고, 해당 값을 코드에서 읽는 법을 연습했다. *(시험 대비: 폼 화면 관련해 **어떤 위젯을 사용해야 하는지** 묻거나, **Radio/Check 용도 차이** 등을 물을 수 있음)*

### 과제 3: 간단 계산기 앱 구현 (버튼 이벤트 다중 처리 실습)
- **과제 개요:** 여러 개의 버튼을 활용한 **간단 계산기** 앱을 구현. 숫자 버튼과 연산자 버튼을 눌러 계산을 수행하고 결과를 화면에 표시한다. 이 과제를 통해 **여러 버튼에 개별 이벤트 할당**하고, **문자열을 동적으로 구성 및 출력**하는 코드를 연습했다.
- **주요 화면 구성:**  
  - **숫자 버튼 (0~9)**: 10개의 Button.  
  - **연산자 버튼 (+, -, *, /, =)**: 필요한 만큼 Button.  
  - **결과 디스플레이:** 계산식과 결과를 보여줄 **TextView 또는 EditText** (비활성화하여 출력용으로 사용).  
  - **레이아웃:** GridLayout이나 TableLayout 등을 이용해 버튼들을 **규칙적인 그리드 형태**로 배치 (예: 4x4 배열로 0-9 및 + - * /, = 버튼 배치). 혹은 LinearLayout을 중첩하여 행별로 배치.  
- **동작 흐름 (예시 시나리오: 더하기 계산):**  
  1. 사용자가 숫자 버튼들을 누르면, 해당 숫자가 문자열로 누적되어 입력된다. 예를 들어 `1` 누르고 `2` 누르면 화면 입력란에 “12” 표시. (구현: 버튼 클릭 리스너마다 TextView의 기존 text에 해당 숫자 문자를 붙여나감, e.g., `textView.setText(textView.getText() + "1")`)  
  2. 사용자가 연산자 `+` 버튼을 누르면, 현재까지 입력한 숫자를 저장하고 연산자도 따로 기억한다. 화면에는 연산자 기호를 함께 표시하거나, 필요시 지우고 다음 숫자 입력 준비. (구현: 변수 `firstNum`에 12 저장, `operator`에 '+' 저장, TextView는 비우거나 기호 표시)  
  3. 사용자가 다음 숫자들을 입력하고, `=` 버튼을 누르면 앞서 저장된 `firstNum`과 현재 입력된 `secondNum`를 꺼내와서, `operator`에 맞게 계산을 수행한다. (예: 12 + 5 = 17)  
  4. 계산 결과를 TextView에 보여준다. 필요하면 이후 추가 계산을 위해 결과를 첫 번째 숫자로 간주하거나 초기화.  
- **핵심 포인트:** 다수의 버튼에 대한 **온클릭 구현**과 **동적인 문자열 처리**이다. 버튼 개수가 많기 때문에 **리스너를 효율적으로 등록**하는 법도 고려했을 수 있다 (예: 별도로 숫자 버튼 10개 각각 리스너 구현 or 하나의 리스너에서 `switch-case`로 `getId()` 분기). 또한 문자열을 숫자로 변환하여 계산할 때 `Integer.parseInt()` 사용, 계산 결과를 다시 문자열로 변환하여 출력하는 과정 등을 다루었다.  
  *(시험 대비: 코드 조각이 주어지고 “이 계산기 코드에서 **잘못된 부분**은?” 또는 계산 순서 이해를 묻는 문제가 나올 수 있다. 예를 들어, 문자열 연결과 parseInt 부분 등에서 오류를 찾는 형태로.)*

### 추가 예제: 이미지 뷰 투명도/회전 기능 구현 (수업 실습 예제)
- **예제 개요:** ImageView와 버튼을 사용하여, **이미지의 속성을 변경**하는 동작을 구현한 실습. (교수님이 강조한 예제로, 시험에 관련 코드나 개념이 나올 수 있음)
- **주요 화면 구성:** 하나의 ImageView (예: 별 그림 또는 로고 이미지)와 두 개의 Button (“투명도 조절”, “회전하기” 등). 필요에 따라 초기 투명도나 회전각도가 설정될 수 있음.
- **동작 흐름:**  
  1. **투명도(Alpha) 버튼 클릭:** 버튼 리스너에서 `imageView.setAlpha(value)`를 호출하여 이미지뷰의 알파값을 변경. 알파(alpha)는 **투명도**를 의미하며 0.0이면 완전히 투명(보이지 않음), 1.0이면 완전히 불투명하게 표시된다. 예제에서는 버튼을 누를 때마다 0.2씩 투명도를 줄이거나(toggle) 하는 방식으로 구현하여, 여러 번 누르면 점점 희미해지는 효과를 보였다.  
  2. **회전(Rotate) 버튼 클릭:** 버튼 클릭 시 `imageView.setRotation(degree)` 또는 `imageView.animate().rotationBy(degree)` 등을 사용하여 이미지를 회전. 한 번 누를 때마다 일정 각도(예: 30도)씩 시계방향 회전하도록 했다. 누를 때 누를 때마다 이미지가 회전되어 새로운 각도로 표시된다.  
  3. (응용) 이 외에도 확대/축소를 위한 `setScaleX/Y`이나 이동 `setTranslationX/Y` 등을 사용할 수도 있지만, 본 예제에서는 알파와 회전에 집중했다.  
- **핵심 포인트:** **View의 속성 변경**을 통해 UI 효과를 주는 방법을 익힌 것. 별도의 복잡한 애니메이션 없이도 간단히 속성만 바꿔도 시각적 변화를 만들 수 있다. (시험에서는 *“setAlpha(0) 호출 시 결과는?”* 식으로 물어볼 수 있으니, **알파값의 의미**(0=투명, 1=불투명)을 기억해둘 것. 또한 회전 각도는 0~360 범위에서 동작하고, 누적 가능함도 알아두기.)

## 파트 3: 예상문제 모음 (객관식 + 서술형)

마지막으로, 교수님의 시험 예고 내용을 토대로 **출제될 법한 예상문제**를 정리합니다. 객관식 문항과 서술형 문항을 섞었으며, 각 문항 아래에 **핵심 키워드/포인트**를 제공하여 공부의 방향을 잡도록 했습니다. 실제 시험에서는 보기가 주어지거나, 서술형은 보다 상세한 답을 요구할 수 있으니 이 키워드를 중심으로 내용을 전개하면 됩니다.

1. **(객관식)** 안드로이드 스튜디오(Android Studio)에 대한 설명으로 옳지 않은 것은?  
   - **키워드:** *Android Studio는 **안드로이드 앱 개발을 위한 IDE**이다 (O). 에뮬레이터를 제공하고 Gradle 빌드 시스템을 사용한다 (O). **안드로이드 기기의 운영체제(OS)이다** (X)*. (👉 **틀린 보기를 찾는 문제**: 정답은 "*운영체제*"처럼 Android Studio의 용도가 아닌 것을 고르는 것)

2. **(객관식)** 안드로이드 운영체제의 특징으로 옳지 않은 것은?  
   - **키워드:** *안드로이드는 **리눅스 기반**이다 (O). **자바/코틀린 언어로 앱을 개발**한다 (O). **아이폰 iOS용 Cocoa Touch 프레임워크를 사용한다** (X). 여러 **미디어 포맷과 센서**를 지원한다 (O). 풍부한 개발도구를 갖추고 있다 (O).* (👉 안드로이드의 대표 특징들을 기억하고, iOS와 혼동되는 내용 골라내기)

3. **(서술형)** 안드로이드 앱의 **4대 구성요소**를 모두 쓰고 간략히 설명하시오.  
   - **키워드:** *액티비티(Activity) - 화면/UI, 사용자와 상호작용. 서비스(Service) - 백그라운드 작업, 화면 없음. 방송 수신자(Broadcast Receiver) - 시스템/앱 이벤트 수신. 컨텐트 제공자(Content Provider) - 앱 간 데이터 공유.* (네 가지 명칭을 정확히 쓰고, 한두 줄씩 역할 설명)

4. **(서술형)** **인텐트(Intent)**란 무엇이며 어떤 역할을 하나요?  
   - **키워드:** *컴포넌트 간의 **메시지/의도 전달 객체**. 액티비티 시작, 서비스 시작, 브로드캐스트 전달 등에 사용. 예: 화면 전환 위해 **다른 액티비티 호출**할 때 인텐트를 이용.* (정의 + 용도 예시)

5. **(객관식)** **PC 애플리케이션**과 **안드로이드 애플리케이션**의 차이로 옳은 것은?  
   - **키워드:** *안드로이드 앱은 **다른 앱의 컴포넌트**를 활용 가능 (예: 카메라 앱 불러오기) => O, PC 앱은 일반적으로 다른 프로세스 코드 사용 불가. 안드로이드 앱은 여러 진입점(컴포넌트) -> **메인 함수가 없음**, LifeCycle 관리됨.* (보기로 PC/안드로이드 특징 섞어서 나올 수 있음, 정답은 **앱 간 연동 가능** 같은 안드로이드만의 특징)

6. **(서술형)** **TextView와 EditText의 차이점**은?  
   - **키워드:** *TextView는 **출력 전용** 텍스트 표시 위젯 – 사용자 편집 불가. EditText는 **사용자 입력 가능**한 텍스트 필드 – 키보드로 입력 받아 수정 가능.* (한 문장씩 비교)

7. **(서술형)** 안드로이드에서 `editText.getText().toString()`을 사용하는 **이유**는 무엇인가?  
   - **키워드:** *`getText()`만 쓰면 **Editable 객체** 반환 -> 문자열 연산에 바로 쓸 수 없음. `.toString()`을 호출해서 **일반 문자열(String)**으로 변환해야 실제 텍스트 값을 얻을 수 있기 때문.* (EditText 내용 추출 방법 설명)

8. **(서술형)** 안드로이드 UI 설계에서 **px, dp, sp**는 각각 무엇이며, 그 차이점을 설명하시오.  
   - **키워드:** *px(Pixel) - **화소 단위**, 화면 픽셀 그대로 표현 (밀도 따라 물리 크기 달라짐). dp(dip) - **밀도 독립 픽셀**, 어떤 기기에서도 **일정한 물리 크기** 보장 (고밀도 화면에서 자동 스케일). sp - **Scaling(pixel) for text**, dp와 비슷하나 **사용자 폰트 크기 설정을 반영** (글자 크기에 사용).* 예를 들어, **고해상도 폰**에서 10px은 아주 작게 보이지만 10dp는 적절한 크기로 조정됨; 텍스트는 10sp로 지정하면 사용자가 설정을 크게 하면 같이 커짐.

9. **(서술형)** XML 레이아웃 속성에서 `wrap_content`와 `match_parent`의 **차이**는 무엇인가?  
   - **키워드:** *`wrap_content` – **자신의 콘텐츠 크기만큼** 뷰 크기를 결정 (내용을 감쌈). `match_parent` – **부모가 허용하는 최대 크기까지** 뷰를 확장 (부모 크기에 맞춤). 예: TextView의 width를 wrap_content로 하면 글자 길이만큼 폭이 결정되고, match_parent로 하면 화면 가득 폭을 차지.* (짧게 정의)

10. **(객관식)** 다음 중 **안드로이드 레이아웃** 종류와 거리가 먼 것은?  
    1) LinearLayout  
    2) ConstraintLayout  
    3) FrameLayout  
    4) IntentLayout  
    - **키워드:** *보기 4) IntentLayout은 실제 존재하지 않는 레이아웃명 -> 정답. (Linear, Constraint, Frame 모두 실제 레이아웃 클래스)*  
    *(혹은)* **LinearLayout과 RelativeLayout의 차이를 한 가지 설명하시오. → *Linear는 일렬(수평/수직) 배치, Relative는 다른 뷰를 기준으로 위치 결정.* (레이아웃 관련 기본 개념)

---
